<!DOCTYPE html>
<html lang="en">
<head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Alam's Scripts</title>
      <link rel="stylesheet" href="commonJS.css">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
      <link rel="preconnect" href="https://fonts.googleapis.com">
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link href="https://fonts.googleapis.com/css2?family=Fragment+Mono:ital@0;1&family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
      <link rel="stylesheet" href="../style.css">
      <link rel="stylesheet" href="../prism.css">
      <script src="../prism.js"></script>
      <link rel="stylesheet" href="../common/common.css">
<body>
      <main>
        <h1>Synchronous vs. Asynchronous in JavaScript</h1>
        <p>Understanding the difference between synchronous and asynchronous operations is crucial in JavaScript, as it impacts how code is executed and how different tasks are managed within an application.</p>
        <h2>1. Synchronous Operations</h2>
        <p>In synchronous programming, tasks are executed sequentially, one after the other. Each task must complete before the next one starts. This means that if a task takes a long time to complete (e.g., fetching data from a server), it can block the entire execution, causing the program to become unresponsive until the task is finished.</p>
        
        <h3>a. How Synchronous Code Works</h3>
        <p>In synchronous code, each line is executed in the order it appears. If a line of code takes time to complete, the entire program will wait (or block) until that line finishes before moving to the next one.</p>
        <h3>b. Example of Synchronous Code</h3>
        <pre class="lang-javascript"><code>console.log('Start');

for (let i = 0; i &lt; 5; i++) {
    console.log(i);
}

console.log('End');</code></pre>
        <h3>Output:</h3>
        <pre class="lang-javascript"><code>Start
0
1
2
3
4
End</code></pre>
        <p>In this example, the loop runs synchronously. The "console.log('End')" statement only executes after the loop finishes.</p>
        <h2>2. Asynchronous Operations</h2>
        <p>Asynchronous programming, on the other hand, allows multiple tasks to run concurrently. When an asynchronous operation is initiated, the program does not wait for it to complete before moving on to the next task. Instead, the operation runs in the background, and a callback function, promise, or other mechanisms can be used to handle the result once it's available.</p>
        <h3>a. How Asynchronous Code Works</h3>
        <p>Asynchronous operations are non-blocking, meaning the program can continue executing other tasks while waiting for the asynchronous task to complete. This is particularly useful for operations that take time, such as network requests, file I/O, or timers.</p>
        <h3>b. Example of Asynchronous Code Using "setTimeout"</h3>
        <pre class="lang-javascript"><code>console.log('Start');

setTimeout(() => {
    console.log('Asynchronous Operation');
}, 2000);

console.log('End');</code></pre>
        <h3>Output:</h3>
        <pre class="lang-javascript"><code>Start
End
Asynchronous Operation</code></pre>
        <p>In this example, "console.log('End')" executes immediately after the "setTimeout" function, without waiting for the 2-second delay. The message "Asynchronous Operation" is logged to the console after the delay.</p>

        <h2>3. Synchronous vs. Asynchronous: Key Differences</h2>
        <ul>
            <li><span>Execution Flow:</span>
            Synchronous code executes sequentially, blocking the next operation until the current one completes. Asynchronous code allows other operations to continue while waiting for the asynchronous task to complete.</li>
            <li><span>Performance:</span>
            Synchronous code can cause performance issues if long-running tasks block the execution. Asynchronous code improves performance by allowing tasks to run concurrently, avoiding delays and unresponsiveness.</li>
            <li><span>Event-Driven Programming:</span>
            JavaScript operates on an event-driven model, where code is executed in response to user actions (e.g., clicking a button, moving the mouse, or typing on the keyboard).</li>
            <li><span>Complexity:</span>
            Asynchronous code can be more complex to manage, particularly when dealing with multiple asynchronous operations that depend on each other.</li>
        </ul>
        
        <h2>4. Common Asynchronous Patterns in JavaScript</h2>
        <h3>a. Callbacks</h3>
        <p>A callback is a function passed as an argument to another function, which is executed once the asynchronous operation completes.</p>
        <pre class="lang-javascript"><code>function fetchData(callback) {
    setTimeout(() => {
        callback('Data fetched');
    }, 2000);
}

console.log('Start');
fetchData((data) => {
    console.log(data);
});
console.log('End');</code></pre>
        <h3>Output:</h3>
        <pre class="lang-javascript"><code>Start
End
Data fetched</code></pre>
        <h3>b. Promises</h3>
        <p>A promise represents a value that may be available now, in the future, or never. It allows you to handle asynchronous operations more elegantly than callbacks.</p>
        <pre class="lang-javascript"><code>function fetchData() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve('Data fetched');
        }, 2000);
    });
}

console.log('Start');
fetchData().then((data) => {
    console.log(data);
});
console.log('End');</code></pre>
        <h3>Output:</h3>
        <pre class="lang-javascript"><code>Start
End
Data fetched</code></pre>
        <h3>c. Async/Await</h3>
        <p>"async/await" is syntactic sugar built on top of promises, allowing you to write asynchronous code that looks synchronous.</p>
        <pre class="lang-javascript"><code>async function fetchData() {
    const data = await new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve('Data fetched');
        }, 2000);
    });
    console.log(data);
}

console.log('Start');
fetchData();
console.log('End');</code></pre>
        <h3>Output:</h3>
        <pre class="lang-javascript"><code>Start
End
Data fetched</code></pre>
        <h2>Conclusion</h2>
        <p>Understanding the difference between synchronous and asynchronous operations is essential for writing efficient and responsive JavaScript code. Synchronous operations are simple but can block execution, while asynchronous operations allow for concurrent tasks, improving performance but adding complexity. By mastering asynchronous patterns like callbacks, promises, and async/await, you can build more robust and scalable applications.</p>
    </main>
    <script src="../common/common.js"></script>
    <script src="commonjs.js"></script>
</body>
</html>