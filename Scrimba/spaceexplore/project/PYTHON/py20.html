<!DOCTYPE html>
<html lang="en">
<head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Alam's Scripts</title>
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
      <link rel="preconnect" href="https://fonts.googleapis.com">
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link href="https://fonts.googleapis.com/css2?family=Fragment+Mono:ital@0;1&family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
      <link rel="stylesheet" href="../style.css">
      <link rel="stylesheet" href="commonPython.css">
      <link rel="stylesheet" href="../common/common.css">
      <link rel="stylesheet" href="../prism.css">
      <script src="../prism.js"></script>
</head>
<body>
      <main>
            <h1>Decorators</h1>
            <p>In Python, decorators are a design pattern that allows you to modify or extend the behavior of functions or methods without altering their original code. They are typically used to add functionality to an existing function in a clean, readable, and reusable way.</p>

            <h2>How decorators work?</h2>
            <p>A decorator is a function that takes another function as input and returns a new function that adds some behavior to the original one. The @decorator_name syntax is used to apply a decorator to a function. Here's the basic structure of a decorator:</p> 
            <h2>Syntax:</h2>
            <pre class="lang-python"><code>def decorator(func):
    def wrapper():
        # Code before the function call
        func()  # Call the original function
        # Code after the function call
    return wrapper
            </code></pre>
            <h2>Explanation:</h2>
                  <ul>
                        <li><span>func:</span>The function being decorated.</li>
                        <li><span>wrapper:</span>
                            A new function that adds extra functionality before and/or after the original function is executed.</li>
                  </ul>

                  <h2>Applying a decorator:</h2>
                  <p>You can apply a decorator to a function by placing the @decorator_name directly above the function definition:</p>
                  <h2>Syntax:</h2>
                  <pre class="lang-python"><code>@decorator
def my_function():
    print("This is my function.")
my_function()
                </code></pre>
                <p>When my_function() is called, the decorator modifies its behavior by adding code before or after the original function's execution.</p>
                <h2>Example:</h2>
                <pre class="lang-python"><code>
def greet_decorator(func):
    def wrapper():
        print("Hello!")
        func()
        print("Goodbye!")
    return wrapper

@greet_decorator
def say_hello():
    print("How are you?")

say_hello()
</code></pre>
            <h2>Output:</h2>
            <pre class="lang-python"><code>Hello!
How are you?
Goodbye!</code></pre>
            <p>In this example, the greet_decorator adds the "Hello!" and "Goodbye!" messages around the say_hello() function.</p>
            <h2>Decorators with arguments:</h2>
            <p>Decorators can also accept arguments. To do this, you add another layer of function nesting:</p>
            <h2>Example:</h2>
            <pre  class="lang-python"><code>def repeat(times):
    def decorator(func):
        def wrapper():
            for _ in range(times):
                func()
            return wrapper
    return decorator     
@repeat(3)
def say_hi():
print("Hi!")
say_hi()
            </code></pre>
            <h2>Use cases of decorators:</h2>
            <ul>
                <li><span>Logging:</span>
                Track the execution of functions for debugging.</li>
                <li><span>Access Control:</span>
                Check user permissions before executing sensitive code.</li>
                <li><span>Memorizing:</span>
                Cache the results of expensive function calls for better performance.</li>
                <li><span>Timing:</span>
                Measure how long a function takes to execute.</li>
            </ul>
            <h2>Conclusion</h2>
            <p>Decorators in Python provide a powerful and flexible way to extend or modify the behavior of functions and methods without altering their original structure. By using decorators, you can keep your code modular, clean, and reusable, making it easier to maintain and scale.</p>
      </main>
      <script src="../common/common.js"></script>
      <script src="commonPython.js"></script>
</body>
</html>